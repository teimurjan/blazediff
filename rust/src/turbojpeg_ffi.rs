/* automatically generated by rust-bindgen 0.72.1 */

pub const TJ_NUMINIT: u32 = 3;
pub const TJ_NUMSAMP: u32 = 7;
pub const TJ_NUMPF: u32 = 12;
pub const TJ_NUMCS: u32 = 5;
pub const TJ_NUMERR: u32 = 2;
pub const TJ_NUMXOP: u32 = 8;
pub const TJXOPT_PERFECT: u32 = 1;
pub const TJXOPT_TRIM: u32 = 2;
pub const TJXOPT_CROP: u32 = 4;
pub const TJXOPT_GRAY: u32 = 8;
pub const TJXOPT_NOOUTPUT: u32 = 16;
pub const TJXOPT_PROGRESSIVE: u32 = 32;
pub const TJXOPT_COPYNONE: u32 = 64;
pub const TJXOPT_ARITHMETIC: u32 = 128;
pub const TJXOPT_OPTIMIZE: u32 = 256;
pub const TJ_BGR: u32 = 1;
pub const TJ_ALPHAFIRST: u32 = 64;
pub const TJ_YUV: u32 = 512;
pub const TJFLAG_BOTTOMUP: u32 = 2;
pub const TJFLAG_FORCEMMX: u32 = 8;
pub const TJFLAG_FORCESSE: u32 = 16;
pub const TJFLAG_FORCESSE2: u32 = 32;
pub const TJFLAG_FORCESSE3: u32 = 128;
pub const TJFLAG_FASTUPSAMPLE: u32 = 256;
pub const TJFLAG_NOREALLOC: u32 = 1024;
pub const TJFLAG_FASTDCT: u32 = 2048;
pub const TJFLAG_ACCURATEDCT: u32 = 4096;
pub const TJFLAG_STOPONWARNING: u32 = 8192;
pub const TJFLAG_PROGRESSIVE: u32 = 16384;
pub const TJFLAG_LIMITSCANS: u32 = 32768;
#[doc = " Initialize the TurboJPEG instance for compression."]
pub const TJINIT_TJINIT_COMPRESS: TJINIT = 0;
#[doc = " Initialize the TurboJPEG instance for decompression."]
pub const TJINIT_TJINIT_DECOMPRESS: TJINIT = 1;
#[doc = " Initialize the TurboJPEG instance for lossless transformation (both\n compression and decompression.)"]
pub const TJINIT_TJINIT_TRANSFORM: TJINIT = 2;
#[doc = " Initialization options"]
pub type TJINIT = ::std::os::raw::c_uint;
#[doc = " 4:4:4 chrominance subsampling (no chrominance subsampling)\n\n The JPEG or YUV image will contain one chrominance component for every\n pixel in the source image."]
pub const TJSAMP_TJSAMP_444: TJSAMP = 0;
#[doc = " 4:2:2 chrominance subsampling\n\n The JPEG or YUV image will contain one chrominance component for every 2x1\n block of pixels in the source image."]
pub const TJSAMP_TJSAMP_422: TJSAMP = 1;
#[doc = " 4:2:0 chrominance subsampling\n\n The JPEG or YUV image will contain one chrominance component for every 2x2\n block of pixels in the source image."]
pub const TJSAMP_TJSAMP_420: TJSAMP = 2;
#[doc = " Grayscale\n\n The JPEG or YUV image will contain no chrominance components."]
pub const TJSAMP_TJSAMP_GRAY: TJSAMP = 3;
#[doc = " 4:4:0 chrominance subsampling\n\n The JPEG or YUV image will contain one chrominance component for every 1x2\n block of pixels in the source image.\n\n @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_440: TJSAMP = 4;
#[doc = " 4:1:1 chrominance subsampling\n\n The JPEG or YUV image will contain one chrominance component for every 4x1\n block of pixels in the source image.  All else being equal, a JPEG image\n with 4:1:1 subsampling is almost exactly the same size as a JPEG image\n with 4:2:0 subsampling, and in the aggregate, both subsampling methods\n produce approximately the same perceptual quality.  However, 4:1:1 is\n better able to reproduce sharp horizontal features.\n\n @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_411: TJSAMP = 5;
#[doc = " 4:4:1 chrominance subsampling\n\n The JPEG or YUV image will contain one chrominance component for every 1x4\n block of pixels in the source image.  All else being equal, a JPEG image\n with 4:4:1 subsampling is almost exactly the same size as a JPEG image\n with 4:2:0 subsampling, and in the aggregate, both subsampling methods\n produce approximately the same perceptual quality.  However, 4:4:1 is\n better able to reproduce sharp vertical features.\n\n @note 4:4:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_441: TJSAMP = 6;
#[doc = " Unknown subsampling\n\n The JPEG image uses an unusual type of chrominance subsampling.  Such\n images can be decompressed into packed-pixel images, but they cannot be\n - decompressed into planar YUV images,\n - losslessly transformed if #TJXOPT_CROP is specified and #TJXOPT_GRAY is\n not specified, or\n - partially decompressed using a cropping region."]
pub const TJSAMP_TJSAMP_UNKNOWN: TJSAMP = -1;
#[doc = " Chrominance subsampling options\n\n When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK\n to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of\n the Cb and Cr (chrominance) components can be discarded or averaged together\n to produce a smaller image with little perceptible loss of image quality.\n (The human eye is more sensitive to small changes in brightness than to\n small changes in color.)  This is called \"chrominance subsampling\"."]
pub type TJSAMP = ::std::os::raw::c_int;
#[doc = " RGB pixel format\n\n The red, green, and blue components in the image are stored in 3-sample\n pixels in the order R, G, B from lowest to highest memory address within\n each pixel."]
pub const TJPF_TJPF_RGB: TJPF = 0;
#[doc = " BGR pixel format\n\n The red, green, and blue components in the image are stored in 3-sample\n pixels in the order B, G, R from lowest to highest memory address within\n each pixel."]
pub const TJPF_TJPF_BGR: TJPF = 1;
#[doc = " RGBX pixel format\n\n The red, green, and blue components in the image are stored in 4-sample\n pixels in the order R, G, B from lowest to highest memory address within\n each pixel.  The X component is ignored when compressing/encoding and\n undefined when decompressing/decoding."]
pub const TJPF_TJPF_RGBX: TJPF = 2;
#[doc = " BGRX pixel format\n\n The red, green, and blue components in the image are stored in 4-sample\n pixels in the order B, G, R from lowest to highest memory address within\n each pixel.  The X component is ignored when compressing/encoding and\n undefined when decompressing/decoding."]
pub const TJPF_TJPF_BGRX: TJPF = 3;
#[doc = " XBGR pixel format\n\n The red, green, and blue components in the image are stored in 4-sample\n pixels in the order R, G, B from highest to lowest memory address within\n each pixel.  The X component is ignored when compressing/encoding and\n undefined when decompressing/decoding."]
pub const TJPF_TJPF_XBGR: TJPF = 4;
#[doc = " XRGB pixel format\n\n The red, green, and blue components in the image are stored in 4-sample\n pixels in the order B, G, R from highest to lowest memory address within\n each pixel.  The X component is ignored when compressing/encoding and\n undefined when decompressing/decoding."]
pub const TJPF_TJPF_XRGB: TJPF = 5;
#[doc = " Grayscale pixel format\n\n Each 1-sample pixel represents a luminance (brightness) level from 0 to\n the maximum sample value (which is, for instance, 255 for 8-bit samples or\n 4095 for 12-bit samples or 65535 for 16-bit samples.)"]
pub const TJPF_TJPF_GRAY: TJPF = 6;
#[doc = " RGBA pixel format\n\n This is the same as @ref TJPF_RGBX, except that when\n decompressing/decoding, the X component is guaranteed to be equal to the\n maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_RGBA: TJPF = 7;
#[doc = " BGRA pixel format\n\n This is the same as @ref TJPF_BGRX, except that when\n decompressing/decoding, the X component is guaranteed to be equal to the\n maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_BGRA: TJPF = 8;
#[doc = " ABGR pixel format\n\n This is the same as @ref TJPF_XBGR, except that when\n decompressing/decoding, the X component is guaranteed to be equal to the\n maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ABGR: TJPF = 9;
#[doc = " ARGB pixel format\n\n This is the same as @ref TJPF_XRGB, except that when\n decompressing/decoding, the X component is guaranteed to be equal to the\n maximum sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ARGB: TJPF = 10;
#[doc = " CMYK pixel format\n\n Unlike RGB, which is an additive color model used primarily for display,\n CMYK (Cyan/Magenta/Yellow/Key) is a subtractive color model used primarily\n for printing.  In the CMYK color model, the value of each color component\n typically corresponds to an amount of cyan, magenta, yellow, or black ink\n that is applied to a white background.  In order to convert between CMYK\n and RGB, it is necessary to use a color management system (CMS.)  A CMS\n will attempt to map colors within the printer's gamut to perceptually\n similar colors in the display's gamut and vice versa, but the mapping is\n typically not 1:1 or reversible, nor can it be defined with a simple\n formula.  Thus, such a conversion is out of scope for a codec library.\n However, the TurboJPEG API allows for compressing packed-pixel CMYK images\n into YCCK JPEG images (see #TJCS_YCCK) and decompressing YCCK JPEG images\n into packed-pixel CMYK images."]
pub const TJPF_TJPF_CMYK: TJPF = 11;
#[doc = " Unknown pixel format\n\n Currently this is only used by #tj3LoadImage8(), #tj3LoadImage12(), and\n #tj3LoadImage16()."]
pub const TJPF_TJPF_UNKNOWN: TJPF = -1;
#[doc = " Pixel formats"]
pub type TJPF = ::std::os::raw::c_int;
#[doc = " RGB colorspace\n\n When generating the JPEG image, the R, G, and B components in the source\n image are reordered into image planes, but no colorspace conversion or\n subsampling is performed.  RGB JPEG images can be generated from and\n decompressed to packed-pixel images with any of the extended RGB or\n grayscale pixel formats, but they cannot be generated from or\n decompressed to planar YUV images."]
pub const TJCS_TJCS_RGB: TJCS = 0;
#[doc = " YCbCr colorspace\n\n YCbCr is not an absolute colorspace but rather a mathematical\n transformation of RGB designed solely for storage and transmission.  YCbCr\n images must be converted to RGB before they can be displayed.  In the\n YCbCr colorspace, the Y (luminance) component represents the black & white\n portion of the original image, and the Cb and Cr (chrominance) components\n represent the color portion of the original image.  Historically, the\n analog equivalent of this transformation allowed the same signal to be\n displayed to both black & white and color televisions, but JPEG images use\n YCbCr primarily because it allows the color data to be optionally\n subsampled in order to reduce network and disk usage.  YCbCr is the most\n common JPEG colorspace, and YCbCr JPEG images can be generated from and\n decompressed to packed-pixel images with any of the extended RGB or\n grayscale pixel formats.  YCbCr JPEG images can also be generated from\n and decompressed to planar YUV images."]
pub const TJCS_TJCS_YCbCr: TJCS = 1;
#[doc = " Grayscale colorspace\n\n The JPEG image retains only the luminance data (Y component), and any\n color data from the source image is discarded.  Grayscale JPEG images can\n be generated from and decompressed to packed-pixel images with any of the\n extended RGB or grayscale pixel formats, or they can be generated from\n and decompressed to planar YUV images."]
pub const TJCS_TJCS_GRAY: TJCS = 2;
#[doc = " CMYK colorspace\n\n When generating the JPEG image, the C, M, Y, and K components in the\n source image are reordered into image planes, but no colorspace conversion\n or subsampling is performed.  CMYK JPEG images can only be generated from\n and decompressed to packed-pixel images with the CMYK pixel format."]
pub const TJCS_TJCS_CMYK: TJCS = 3;
#[doc = " YCCK colorspace\n\n YCCK (AKA \"YCbCrK\") is not an absolute colorspace but rather a\n mathematical transformation of CMYK designed solely for storage and\n transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be\n reversibly transformed into YCCK, and as with YCbCr, the chrominance\n components in the YCCK pixels can be subsampled without incurring major\n perceptual loss.  YCCK JPEG images can only be generated from and\n decompressed to packed-pixel images with the CMYK pixel format."]
pub const TJCS_TJCS_YCCK: TJCS = 4;
#[doc = " JPEG colorspaces"]
pub type TJCS = ::std::os::raw::c_uint;
#[doc = " Error handling behavior\n\n **Value**\n - `0` *[default]* Allow the current compression/decompression/transform\n operation to complete unless a fatal error is encountered.\n - `1` Immediately discontinue the current\n compression/decompression/transform operation if a warning (non-fatal\n error) occurs."]
pub const TJPARAM_TJPARAM_STOPONWARNING: TJPARAM = 0;
#[doc = " Row order in packed-pixel source/destination images\n\n **Value**\n - `0` *[default]* top-down (X11) order\n - `1` bottom-up (Windows, OpenGL) order"]
pub const TJPARAM_TJPARAM_BOTTOMUP: TJPARAM = 1;
#[doc = " JPEG destination buffer (re)allocation [compression, lossless\n transformation]\n\n **Value**\n - `0` *[default]* Attempt to allocate or reallocate the JPEG destination\n buffer as needed.\n - `1` Generate an error if the JPEG destination buffer is invalid or too\n small."]
pub const TJPARAM_TJPARAM_NOREALLOC: TJPARAM = 2;
#[doc = " Perceptual quality of lossy JPEG images [compression only]\n\n **Value**\n - `1`-`100` (`1` = worst quality but best compression, `100` = best\n quality but worst compression) *[no default; must be explicitly\n specified]*"]
pub const TJPARAM_TJPARAM_QUALITY: TJPARAM = 3;
#[doc = " Chrominance subsampling level\n\n The JPEG or YUV image uses (decompression, decoding) or will use (lossy\n compression, encoding) the specified level of chrominance subsampling.\n\n **Value**\n - One of the @ref TJSAMP \"chrominance subsampling options\" *[no default;\n must be explicitly specified for lossy compression, encoding, and\n decoding]*"]
pub const TJPARAM_TJPARAM_SUBSAMP: TJPARAM = 4;
#[doc = " JPEG width (in pixels) [decompression only, read-only]"]
pub const TJPARAM_TJPARAM_JPEGWIDTH: TJPARAM = 5;
#[doc = " JPEG height (in pixels) [decompression only, read-only]"]
pub const TJPARAM_TJPARAM_JPEGHEIGHT: TJPARAM = 6;
#[doc = " Data precision (bits per sample)\n\n The JPEG image uses (decompression) or will use (lossless compression) the\n specified number of bits per sample.  This parameter also specifies the\n target data precision when loading a PBMPLUS file with #tj3LoadImage8(),\n #tj3LoadImage12(), or #tj3LoadImage16() and the source data precision when\n saving a PBMPLUS file with #tj3SaveImage8(), #tj3SaveImage12(), or\n #tj3SaveImage16().\n\n The data precision is the number of bits in the maximum sample value,\n which may not be the same as the width of the data type used to store the\n sample.\n\n **Value**\n - `8` or `12` for lossy JPEG images; `2` to `16` for lossless JPEG and\n PBMPLUS images\n\n 12-bit JPEG data precision implies #TJPARAM_OPTIMIZE unless\n #TJPARAM_ARITHMETIC is set."]
pub const TJPARAM_TJPARAM_PRECISION: TJPARAM = 7;
#[doc = " JPEG colorspace\n\n The JPEG image uses (decompression) or will use (lossy compression) the\n specified colorspace.\n\n **Value**\n - One of the @ref TJCS \"JPEG colorspaces\" *[default for lossy compression:\n automatically selected based on the subsampling level and pixel format]*"]
pub const TJPARAM_TJPARAM_COLORSPACE: TJPARAM = 8;
#[doc = " Chrominance upsampling algorithm [lossy decompression only]\n\n **Value**\n - `0` *[default]* Use smooth upsampling when decompressing a JPEG image\n that was generated using chrominance subsampling.  This creates a smooth\n transition between neighboring chrominance components in order to reduce\n upsampling artifacts in the decompressed image.\n - `1` Use the fastest chrominance upsampling algorithm available, which\n may combine upsampling with color conversion."]
pub const TJPARAM_TJPARAM_FASTUPSAMPLE: TJPARAM = 9;
#[doc = " DCT/IDCT algorithm [lossy compression and decompression]\n\n **Value**\n - `0` *[default]* Use the most accurate DCT/IDCT algorithm available.\n - `1` Use the fastest DCT/IDCT algorithm available.\n\n This parameter is provided mainly for backward compatibility with libjpeg,\n which historically implemented several different DCT/IDCT algorithms\n because of performance limitations with 1990s CPUs.  In the libjpeg-turbo\n implementation of the TurboJPEG API:\n - The \"fast\" and \"accurate\" DCT/IDCT algorithms perform similarly on\n modern x86/x86-64 CPUs that support AVX2 instructions.\n - The \"fast\" algorithm is generally only about 5-15% faster than the\n \"accurate\" algorithm on other types of CPUs.\n - The difference in accuracy between the \"fast\" and \"accurate\" algorithms\n is the most pronounced at JPEG quality levels above 90 and tends to be\n more pronounced with decompression than with compression.\n - For JPEG quality levels above 97, the \"fast\" algorithm degrades and is\n not fully accelerated, so it is slower than the \"accurate\" algorithm."]
pub const TJPARAM_TJPARAM_FASTDCT: TJPARAM = 10;
#[doc = " Huffman table optimization [lossy compression, lossless transformation]\n\n **Value**\n - `0` *[default]* The JPEG image will use the default Huffman tables.\n - `1` Optimal Huffman tables will be computed for the JPEG image.  For\n lossless transformation, this can also be specified using\n #TJXOPT_OPTIMIZE.\n\n Huffman table optimization improves compression slightly (generally 5% or\n less), but it reduces compression performance considerably."]
pub const TJPARAM_TJPARAM_OPTIMIZE: TJPARAM = 11;
#[doc = " Progressive JPEG\n\n In a progressive JPEG image, the DCT coefficients are split across\n multiple \"scans\" of increasing quality.  Thus, a low-quality scan\n containing the lowest-frequency DCT coefficients can be transmitted first\n and refined with subsequent higher-quality scans containing\n higher-frequency DCT coefficients.  When using Huffman entropy coding, the\n progressive JPEG format also provides an \"end-of-bands (EOB) run\" feature\n that allows large groups of zeroes, potentially spanning multiple MCUs,\n to be represented using only a few bytes.\n\n **Value**\n - `0` *[default for compression, lossless transformation]* The lossy JPEG\n image is (decompression) or will be (compression, lossless transformation)\n single-scan.\n - `1` The lossy JPEG image is (decompression) or will be (compression,\n lossless transformation) progressive.  For lossless transformation, this\n can also be specified using #TJXOPT_PROGRESSIVE.\n\n Progressive JPEG images generally have better compression ratios than\n single-scan JPEG images (much better if the image has large areas of solid\n color), but progressive JPEG compression and decompression is considerably\n slower than single-scan JPEG compression and decompression.  Can be\n combined with #TJPARAM_ARITHMETIC.  Implies #TJPARAM_OPTIMIZE unless\n #TJPARAM_ARITHMETIC is also set."]
pub const TJPARAM_TJPARAM_PROGRESSIVE: TJPARAM = 12;
#[doc = " Progressive JPEG scan limit for lossy JPEG images [decompression, lossless\n transformation]\n\n Setting this parameter causes the decompression and transform functions to\n return an error if the number of scans in a progressive JPEG image exceeds\n the specified limit.  The primary purpose of this is to allow\n security-critical applications to guard against an exploit of the\n progressive JPEG format described in\n <a href=\"https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf\" target=\"_blank\">this report</a>.\n\n **Value**\n - maximum number of progressive JPEG scans that the decompression and\n transform functions will process *[default: `0` (no limit)]*\n\n @see #TJPARAM_PROGRESSIVE"]
pub const TJPARAM_TJPARAM_SCANLIMIT: TJPARAM = 13;
#[doc = " Arithmetic entropy coding\n\n **Value**\n - `0` *[default for compression, lossless transformation]* The lossy JPEG\n image uses (decompression) or will use (compression, lossless\n transformation) Huffman entropy coding.\n - `1` The lossy JPEG image uses (decompression) or will use (compression,\n lossless transformation) arithmetic entropy coding.  For lossless\n transformation, this can also be specified using #TJXOPT_ARITHMETIC.\n\n Arithmetic entropy coding generally improves compression relative to\n Huffman entropy coding, but it reduces compression and decompression\n performance considerably.  Can be combined with #TJPARAM_PROGRESSIVE."]
pub const TJPARAM_TJPARAM_ARITHMETIC: TJPARAM = 14;
#[doc = " Lossless JPEG\n\n **Value**\n - `0` *[default for compression]* The JPEG image is (decompression) or\n will be (compression) lossy/DCT-based.\n - `1` The JPEG image is (decompression) or will be (compression)\n lossless/predictive.\n\n In most cases, lossless JPEG compression and decompression is considerably\n slower than lossy JPEG compression and decompression, and lossless JPEG\n images are much larger than lossy JPEG images.  Thus, lossless JPEG images\n are typically used only for applications that require mathematically\n lossless compression.  Also note that the following features are not\n available with lossless JPEG images:\n - Colorspace conversion (lossless JPEG images always use #TJCS_RGB,\n #TJCS_GRAY, or #TJCS_CMYK, depending on the pixel format of the source\n image)\n - Chrominance subsampling (lossless JPEG images always use #TJSAMP_444)\n - JPEG quality selection\n - DCT/IDCT algorithm selection\n - Progressive JPEG\n - Arithmetic entropy coding\n - Compression from/decompression to planar YUV images (this parameter is\n ignored by #tj3CompressFromYUV8() and #tj3CompressFromYUVPlanes8())\n - Decompression scaling\n - Lossless transformation\n\n @see #TJPARAM_LOSSLESSPSV, #TJPARAM_LOSSLESSPT"]
pub const TJPARAM_TJPARAM_LOSSLESS: TJPARAM = 15;
#[doc = " Lossless JPEG predictor selection value (PSV)\n\n **Value**\n - `1`-`7` *[default for compression: `1`]*\n\n Lossless JPEG compression shares no algorithms with lossy JPEG\n compression.  Instead, it uses differential pulse-code modulation (DPCM),\n an algorithm whereby each sample is encoded as the difference between the\n sample's value and a \"predictor\", which is based on the values of\n neighboring samples.  If Ra is the sample immediately to the left of the\n current sample, Rb is the sample immediately above the current sample, and\n Rc is the sample diagonally to the left and above the current sample, then\n the relationship between the predictor selection value and the predictor\n is as follows:\n\n PSV | Predictor\n ----|----------\n 1   | Ra\n 2   | Rb\n 3   | Rc\n 4   | Ra + Rb – Rc\n 5   | Ra + (Rb – Rc) / 2\n 6   | Rb + (Ra – Rc) / 2\n 7   | (Ra + Rb) / 2\n\n Predictors 1-3 are 1-dimensional predictors, whereas Predictors 4-7 are\n 2-dimensional predictors.  The best predictor for a particular image\n depends on the image.\n\n @see #TJPARAM_LOSSLESS"]
pub const TJPARAM_TJPARAM_LOSSLESSPSV: TJPARAM = 16;
#[doc = " Lossless JPEG point transform (Pt)\n\n **Value**\n - `0` through ***precision*** *- 1*, where ***precision*** is the JPEG\n data precision in bits *[default for compression: `0`]*\n\n A point transform value of `0` is necessary in order to generate a fully\n lossless JPEG image.  (A non-zero point transform value right-shifts the\n input samples by the specified number of bits, which is effectively a form\n of lossy color quantization.)\n\n @see #TJPARAM_LOSSLESS, #TJPARAM_PRECISION"]
pub const TJPARAM_TJPARAM_LOSSLESSPT: TJPARAM = 17;
#[doc = " JPEG restart marker interval in MCUs [lossy compression,\n lossless transformation]\n\n The nature of entropy coding is such that a corrupt JPEG image cannot\n be decompressed beyond the point of corruption unless it contains restart\n markers.  A restart marker stops and restarts the entropy coding algorithm\n so that, if a JPEG image is corrupted, decompression can resume at the\n next marker.  Thus, adding more restart markers improves the fault\n tolerance of the JPEG image, but adding too many restart markers can\n adversely affect the compression ratio and performance.\n\n In typical JPEG images, an MCU (Minimum Coded Unit) is the minimum set of\n interleaved \"data units\" (8x8 DCT blocks if the image is lossy or samples\n if the image is lossless) necessary to represent at least one data unit\n per component.  (For example, an MCU in an interleaved lossy JPEG image\n that uses 4:2:2 subsampling consists of two luminance blocks followed by\n one block for each chrominance component.)  In single-component or\n non-interleaved JPEG images, an MCU is the same as a data unit.\n\n **Value**\n - the number of MCUs between each restart marker *[default: `0` (no\n restart markers)]*\n\n Setting this parameter to a non-zero value sets #TJPARAM_RESTARTROWS to 0."]
pub const TJPARAM_TJPARAM_RESTARTBLOCKS: TJPARAM = 18;
#[doc = " JPEG restart marker interval in MCU rows [compression,\n lossless transformation]\n\n See #TJPARAM_RESTARTBLOCKS for a description of restart markers and MCUs.\n An MCU row is a row of MCUs spanning the entire width of the image.\n\n **Value**\n - the number of MCU rows between each restart marker *[default: `0` (no\n restart markers)]*\n\n Setting this parameter to a non-zero value sets #TJPARAM_RESTARTBLOCKS to\n 0."]
pub const TJPARAM_TJPARAM_RESTARTROWS: TJPARAM = 19;
#[doc = " JPEG horizontal pixel density\n\n **Value**\n - The JPEG image has (decompression) or will have (compression) the\n specified horizontal pixel density *[default for compression: `1`]*.\n\n This value is stored in or read from the JPEG header.  It does not affect\n the contents of the JPEG image.  Note that this parameter is set by\n #tj3LoadImage8() when loading a Windows BMP file that contains pixel\n density information, and the value of this parameter is stored to a\n Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS\n is `2`.\n\n This parameter has no effect unless the JPEG colorspace (see\n #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.\n\n @see TJPARAM_DENSITYUNITS"]
pub const TJPARAM_TJPARAM_XDENSITY: TJPARAM = 20;
#[doc = " JPEG vertical pixel density\n\n **Value**\n - The JPEG image has (decompression) or will have (compression) the\n specified vertical pixel density *[default for compression: `1`]*.\n\n This value is stored in or read from the JPEG header.  It does not affect\n the contents of the JPEG image.  Note that this parameter is set by\n #tj3LoadImage8() when loading a Windows BMP file that contains pixel\n density information, and the value of this parameter is stored to a\n Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS\n is `2`.\n\n This parameter has no effect unless the JPEG colorspace (see\n #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.\n\n @see TJPARAM_DENSITYUNITS"]
pub const TJPARAM_TJPARAM_YDENSITY: TJPARAM = 21;
#[doc = " JPEG pixel density units\n\n **Value**\n - `0` *[default for compression]* The pixel density of the JPEG image is\n expressed (decompression) or will be expressed (compression) in unknown\n units.\n - `1` The pixel density of the JPEG image is expressed (decompression) or\n will be expressed (compression) in units of pixels/inch.\n - `2` The pixel density of the JPEG image is expressed (decompression) or\n will be expressed (compression) in units of pixels/cm.\n\n This value is stored in or read from the JPEG header.  It does not affect\n the contents of the JPEG image.  Note that this parameter is set by\n #tj3LoadImage8() when loading a Windows BMP file that contains pixel\n density information, and the value of this parameter is stored to a\n Windows BMP file by #tj3SaveImage8() if the value is `2`.\n\n This parameter has no effect unless the JPEG colorspace (see\n #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.\n\n @see TJPARAM_XDENSITY, TJPARAM_YDENSITY"]
pub const TJPARAM_TJPARAM_DENSITYUNITS: TJPARAM = 22;
#[doc = " Memory limit for intermediate buffers\n\n **Value**\n - the maximum amount of memory (in megabytes) that will be allocated for\n intermediate buffers, which are used with progressive JPEG compression and\n decompression, Huffman table optimization, lossless JPEG compression, and\n lossless transformation *[default: `0` (no limit)]*"]
pub const TJPARAM_TJPARAM_MAXMEMORY: TJPARAM = 23;
#[doc = " Image size limit [decompression, lossless transformation, packed-pixel\n image loading]\n\n Setting this parameter causes the decompression, transform, and image\n loading functions to return an error if the number of pixels in the source\n image exceeds the specified limit.  This allows security-critical\n applications to guard against excessive memory consumption.\n\n **Value**\n - maximum number of pixels that the decompression, transform, and image\n loading functions will process *[default: `0` (no limit)]*"]
pub const TJPARAM_TJPARAM_MAXPIXELS: TJPARAM = 24;
#[doc = " Marker copying behavior [decompression, lossless transformation]\n\n **Value [lossless transformation]**\n - `0` Do not copy any extra markers (including comments, JFIF thumbnails,\n Exif data, and ICC profile data) from the source image to the destination\n image.\n - `1` Do not copy any extra markers, except comment (COM) markers, from\n the source image to the destination image.\n - `2` *[default]* Copy all extra markers from the source image to the\n destination image.\n - `3` Copy all extra markers, except ICC profile data (APP2 markers), from\n the source image to the destination image.\n - `4` Do not copy any extra markers, except ICC profile data (APP2\n markers), from the source image to the destination image.\n\n #TJXOPT_COPYNONE overrides this parameter for a particular transform.\n This parameter overrides any ICC profile that was previously associated\n with the TurboJPEG instance using #tj3SetICCProfile().\n\n When decompressing, #tj3DecompressHeader() extracts the ICC profile from a\n JPEG image if this parameter is set to `2` or `4`.  #tj3GetICCProfile()\n can then be used to retrieve the profile."]
pub const TJPARAM_TJPARAM_SAVEMARKERS: TJPARAM = 25;
#[doc = " Parameters"]
pub type TJPARAM = ::std::os::raw::c_uint;
#[doc = " The error was non-fatal and recoverable, but the destination image may\n still be corrupt."]
pub const TJERR_TJERR_WARNING: TJERR = 0;
#[doc = " The error was fatal and non-recoverable."]
pub const TJERR_TJERR_FATAL: TJERR = 1;
#[doc = " Error codes"]
pub type TJERR = ::std::os::raw::c_uint;
#[doc = " Do not transform the position of the image pixels."]
pub const TJXOP_TJXOP_NONE: TJXOP = 0;
#[doc = " Flip (mirror) image horizontally.  This transform is imperfect if there\n are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_HFLIP: TJXOP = 1;
#[doc = " Flip (mirror) image vertically.  This transform is imperfect if there are\n any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_VFLIP: TJXOP = 2;
#[doc = " Transpose image (flip/mirror along upper left to lower right axis.)  This\n transform is always perfect."]
pub const TJXOP_TJXOP_TRANSPOSE: TJXOP = 3;
#[doc = " Transverse transpose image (flip/mirror along upper right to lower left\n axis.)  This transform is imperfect if there are any partial iMCUs in the\n image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_TRANSVERSE: TJXOP = 4;
#[doc = " Rotate image clockwise by 90 degrees.  This transform is imperfect if\n there are any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT90: TJXOP = 5;
#[doc = " Rotate image 180 degrees.  This transform is imperfect if there are any\n partial iMCUs in the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT180: TJXOP = 6;
#[doc = " Rotate image counter-clockwise by 90 degrees.  This transform is imperfect\n if there are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT270: TJXOP = 7;
#[doc = " Transform operations for #tj3Transform()"]
pub type TJXOP = ::std::os::raw::c_uint;
#[doc = " Scaling factor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjscalingfactor {
    #[doc = " Numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = " Denominator"]
    pub denom: ::std::os::raw::c_int,
}
#[doc = " Cropping region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjregion {
    #[doc = " The left boundary of the cropping region.  For lossless transformation,\n this must be evenly divisible by the iMCU width (see #tjMCUWidth) of the\n destination image.  For decompression, this must be evenly divisible by\n the scaled iMCU width of the source image."]
    pub x: ::std::os::raw::c_int,
    #[doc = " The upper boundary of the cropping region.  For lossless transformation,\n this must be evenly divisible by the iMCU height (see #tjMCUHeight) of the\n destination image."]
    pub y: ::std::os::raw::c_int,
    #[doc = " The width of the cropping region.  Setting this to 0 is the equivalent of\n setting it to the width of the source JPEG image - x."]
    pub w: ::std::os::raw::c_int,
    #[doc = " The height of the cropping region.  Setting this to 0 is the equivalent of\n setting it to the height of the source JPEG image - y."]
    pub h: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " A #tjregion structure that specifies no cropping"]
    pub static TJUNCROPPED: tjregion;
}
#[doc = " Lossless transform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjtransform {
    #[doc = " Cropping region"]
    pub r: tjregion,
    #[doc = " One of the @ref TJXOP \"transform operations\""]
    pub op: ::std::os::raw::c_int,
    #[doc = " The bitwise OR of one of more of the @ref TJXOPT_ARITHMETIC\n \"transform options\""]
    pub options: ::std::os::raw::c_int,
    #[doc = " Arbitrary data that can be accessed within the body of the callback\n function"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " A callback function that can be used to modify the DCT coefficients after\n they are losslessly transformed but before they are transcoded to a new\n JPEG image.  This allows for custom filters or other transformations to be\n applied in the frequency domain.\n\n @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:\n This pointer is not guaranteed to be valid once the callback returns, so\n applications wishing to hand off the DCT coefficients to another function\n or library should make a copy of them within the body of the callback.)\n\n @param arrayRegion #tjregion structure containing the width and height of\n the array pointed to by `coeffs` as well as its offset relative to the\n component plane.  TurboJPEG implementations may choose to split each\n component plane into multiple DCT coefficient arrays and call the callback\n function once for each array.\n\n @param planeRegion #tjregion structure containing the width and height of\n the component plane to which `coeffs` belongs\n\n @param componentID ID number of the component plane to which `coeffs`\n belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in\n typical JPEG images.)\n\n @param transformID ID number of the transformed image to which `coeffs`\n belongs.  This is the same as the index of the transform in the\n `transforms` array that was passed to #tj3Transform().\n\n @param transform a pointer to a #tjtransform structure that specifies the\n parameters and/or cropping region for this transform\n\n @return 0 if the callback was successful, or -1 if an error occurred."]
    pub customFilter: ::std::option::Option<
        unsafe extern "C" fn(
            coeffs: *mut ::std::os::raw::c_short,
            arrayRegion: tjregion,
            planeRegion: tjregion,
            componentID: ::std::os::raw::c_int,
            transformID: ::std::os::raw::c_int,
            transform: *mut tjtransform,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " TurboJPEG instance handle"]
pub type tjhandle = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    #[doc = " A #tjscalingfactor structure that specifies a scaling factor of 1/1 (no\n scaling)"]
    pub static TJUNSCALED: tjscalingfactor;
}
unsafe extern "C" {
    #[doc = " Create a new TurboJPEG instance.\n\n @param initType one of the @ref TJINIT \"initialization options\"\n\n @return a handle to the newly-created instance, or NULL if an error occurred\n (see #tj3GetErrorStr().)"]
    pub fn tj3Init(initType: ::std::os::raw::c_int) -> tjhandle;
}
unsafe extern "C" {
    #[doc = " Destroy a TurboJPEG instance.\n\n @param handle handle to a TurboJPEG instance.  If the handle is NULL, then\n this function has no effect."]
    pub fn tj3Destroy(handle: tjhandle);
}
unsafe extern "C" {
    #[doc = " Returns a descriptive error message explaining why the last command failed.\n\n @param handle handle to a TurboJPEG instance, or NULL if the error was\n generated by a global function (but note that retrieving the error message\n for a global function is thread-safe only on platforms that support\n thread-local storage.)\n\n @return a descriptive error message explaining why the last command failed."]
    pub fn tj3GetErrorStr(handle: tjhandle) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns a code indicating the severity of the last error.  See\n @ref TJERR \"Error codes\".\n\n @param handle handle to a TurboJPEG instance\n\n @return a code indicating the severity of the last error.  See\n @ref TJERR \"Error codes\"."]
    pub fn tj3GetErrorCode(handle: tjhandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the value of a parameter.\n\n @param handle handle to a TurboJPEG instance\n\n @param param one of the @ref TJPARAM \"parameters\"\n\n @param value value of the parameter (refer to @ref TJPARAM\n \"parameter documentation\")\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3Set(
        handle: tjhandle,
        param: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the value of a parameter.\n\n @param handle handle to a TurboJPEG instance\n\n @param param one of the @ref TJPARAM \"parameters\"\n\n @return the value of the specified parameter, or -1 if the value is unknown."]
    pub fn tj3Get(handle: tjhandle, param: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate a byte buffer for use with TurboJPEG.  You should always use this\n function to allocate the JPEG destination buffer(s) for the compression and\n transform functions unless you are disabling automatic buffer (re)allocation\n (by setting #TJPARAM_NOREALLOC.)\n\n @param bytes the number of bytes to allocate\n\n @return a pointer to a newly-allocated buffer with the specified number of\n bytes.\n\n @see tj3Free()"]
    pub fn tj3Alloc(bytes: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Free a byte buffer previously allocated by TurboJPEG.  You should always use\n this function to free JPEG destination buffer(s) that were automatically\n (re)allocated by the compression and transform functions or that were\n manually allocated using #tj3Alloc().\n\n @param buffer address of the buffer to free.  If the address is NULL, then\n this function has no effect.\n\n @see tj3Alloc()"]
    pub fn tj3Free(buffer: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image with\n the given parameters.  The number of bytes returned by this function is\n larger than the size of the uncompressed source image.  The reason for this\n is that the JPEG format uses 16-bit coefficients, so it is possible for a\n very high-quality source image with very high-frequency content to expand\n rather than compress when converted to the JPEG format.  Such images\n represent very rare corner cases, but since there is no way to predict the\n size of a JPEG image prior to compression, the corner cases have to be\n handled.\n\n @param width width (in pixels) of the image\n\n @param height height (in pixels) of the image\n\n @param jpegSubsamp the level of chrominance subsampling to be used when\n generating the JPEG image (see @ref TJSAMP\n \"Chrominance subsampling options\".)  #TJSAMP_UNKNOWN is treated like\n #TJSAMP_444, since a buffer large enough to hold a JPEG image with no\n subsampling should also be large enough to hold a JPEG image with an\n arbitrary level of subsampling.  Note that lossless JPEG images always\n use #TJSAMP_444.\n\n @return the maximum size of the buffer (in bytes) required to hold the\n image, or 0 if the arguments are out of bounds."]
    pub fn tj3JPEGBufSize(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        jpegSubsamp: ::std::os::raw::c_int,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a unified planar YUV\n image with the given parameters.\n\n @param width width (in pixels) of the image\n\n @param align row alignment (in bytes) of the image (must be a power of 2.)\n Setting this parameter to n specifies that each row in each plane of the\n image will be padded to the nearest multiple of n bytes (1 = unpadded.)\n\n @param height height (in pixels) of the image\n\n @param subsamp level of chrominance subsampling in the image (see\n @ref TJSAMP \"Chrominance subsampling options\".)\n\n @return the size of the buffer (in bytes) required to hold the image, or 0\n if the arguments are out of bounds."]
    pub fn tj3YUVBufSize(
        width: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a YUV image plane with\n the given parameters.\n\n @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n\n @param width width (in pixels) of the YUV image.  NOTE: This is the width of\n the whole image, not the plane width.\n\n @param stride bytes per row in the image plane.  Setting this to 0 is the\n equivalent of setting it to the plane width.\n\n @param height height (in pixels) of the YUV image.  NOTE: This is the height\n of the whole image, not the plane height.\n\n @param subsamp level of chrominance subsampling in the image (see\n @ref TJSAMP \"Chrominance subsampling options\".)\n\n @return the size of the buffer (in bytes) required to hold the YUV image\n plane, or 0 if the arguments are out of bounds."]
    pub fn tj3YUVPlaneSize(
        componentID: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " The plane width of a YUV image plane with the given parameters.  Refer to\n @ref YUVnotes \"YUV Image Format Notes\" for a description of plane width.\n\n @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n\n @param width width (in pixels) of the YUV image\n\n @param subsamp level of chrominance subsampling in the image (see\n @ref TJSAMP \"Chrominance subsampling options\".)\n\n @return the plane width of a YUV image plane with the given parameters, or 0\n if the arguments are out of bounds."]
    pub fn tj3YUVPlaneWidth(
        componentID: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The plane height of a YUV image plane with the given parameters.  Refer to\n @ref YUVnotes \"YUV Image Format Notes\" for a description of plane height.\n\n @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n\n @param height height (in pixels) of the YUV image\n\n @param subsamp level of chrominance subsampling in the image (see\n @ref TJSAMP \"Chrominance subsampling options\".)\n\n @return the plane height of a YUV image plane with the given parameters, or\n 0 if the arguments are out of bounds."]
    pub fn tj3YUVPlaneHeight(
        componentID: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Embed an ICC (International Color Consortium) color management profile in\n JPEG images generated by subsequent compression and lossless transformation\n operations.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param iccBuf pointer to a byte buffer containing an ICC profile.  A copy is\n made of the ICC profile, so this buffer can be freed or reused as soon as\n this function returns.  Setting this parameter to NULL or setting `iccSize`\n to 0 removes any ICC profile that was previously associated with the\n TurboJPEG instance.\n\n @param iccSize size of the ICC profile (in bytes.)  Setting this parameter\n to 0 or setting `iccBuf` to NULL removes any ICC profile that was previously\n associated with the TurboJPEG instance.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetICCProfile(
        handle: tjhandle,
        iccBuf: *mut ::std::os::raw::c_uchar,
        iccSize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compress a packed-pixel RGB, grayscale, or CMYK image with 2 to 8 bits of\n data precision per sample into a JPEG image with the same data precision.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,\n or CMYK source image to be compressed.  This buffer should normally be\n `pitch * height` samples in size.  However, you can also use this parameter\n to compress from a specific region of a larger buffer.  The data precision\n of the source image (from 2 to 8 bits per sample) can be specified using\n #TJPARAM_PRECISION and defaults to 8 if #TJPARAM_PRECISION is unset or out\n of range.\n\n @param width width (in pixels) of the source image\n\n @param pitch samples per row in the source image.  Normally this should be\n <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n (Setting this parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n parameter to specify the row alignment/padding of the source image, to skip\n rows, or to compress from a specific region of a larger buffer.\n\n @param height height (in pixels) of the source image\n\n @param pixelFormat pixel format of the source image (see @ref TJPF\n \"Pixel formats\".)\n\n @param jpegBuf address of a pointer to a byte buffer that will receive the\n JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n accommodate the size of the JPEG image.  Thus, you can choose to:\n -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n let TurboJPEG grow the buffer as needed,\n -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n or\n -# pre-allocate the buffer to a \"worst case\" size determined by calling\n #tj3JPEGBufSize() and adding the return value to the size of the ICC profile\n (if any) that was previously associated with the TurboJPEG instance (see\n #tj3SetICCProfile().)  This should ensure that the buffer never has to be\n re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n .\n Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`\n upon return from this function, as it may have changed.\n\n @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n should be set to the size of the buffer.  Otherwise, `*jpegSize` is\n ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a\n previous call to one of the JPEG compression functions, then `*jpegSize` is\n also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG\n image (in bytes.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3Compress8(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compress a packed-pixel RGB, grayscale, or CMYK image with 9 to 12 bits of\n data precision per sample into a JPEG image with the same data precision.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,\n or CMYK source image to be compressed.  This buffer should normally be\n `pitch * height` samples in size.  However, you can also use this parameter\n to compress from a specific region of a larger buffer.  The data precision\n of the source image (from 9 to 12 bits per sample) can be specified using\n #TJPARAM_PRECISION and defaults to 12 if #TJPARAM_PRECISION is unset or out\n of range.\n\n @param width width (in pixels) of the source image\n\n @param pitch samples per row in the source image.  Normally this should be\n <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n (Setting this parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n parameter to specify the row alignment/padding of the source image, to skip\n rows, or to compress from a specific region of a larger buffer.\n\n @param height height (in pixels) of the source image\n\n @param pixelFormat pixel format of the source image (see @ref TJPF\n \"Pixel formats\".)\n\n @param jpegBuf address of a pointer to a byte buffer that will receive the\n JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n accommodate the size of the JPEG image.  Thus, you can choose to:\n -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n let TurboJPEG grow the buffer as needed,\n -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n or\n -# pre-allocate the buffer to a \"worst case\" size determined by calling\n #tj3JPEGBufSize() and adding the return value to the size of the ICC profile\n (if any) that was previously associated with the TurboJPEG instance (see\n #tj3SetICCProfile().)  This should ensure that the buffer never has to be\n re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n .\n Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`\n upon return from this function, as it may have changed.\n\n @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n should be set to the size of the buffer.  Otherwise, `*jpegSize` is\n ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a\n previous call to one of the JPEG compression functions, then `*jpegSize` is\n also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG\n image (in bytes.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3Compress12(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_short,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compress a packed-pixel RGB, grayscale, or CMYK image with 13 to 16 bits of\n data precision per sample into a lossless JPEG image with the same data\n precision.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,\n or CMYK source image to be compressed.  This buffer should normally be\n `pitch * height` samples in size.  However, you can also use this parameter\n to compress from a specific region of a larger buffer.  The data precision\n of the source image (from 13 to 16 bits per sample) can be specified using\n #TJPARAM_PRECISION and defaults to 16 if #TJPARAM_PRECISION is unset or out\n of range.\n\n @param width width (in pixels) of the source image\n\n @param pitch samples per row in the source image.  Normally this should be\n <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n (Setting this parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n parameter to specify the row alignment/padding of the source image, to skip\n rows, or to compress from a specific region of a larger buffer.\n\n @param height height (in pixels) of the source image\n\n @param pixelFormat pixel format of the source image (see @ref TJPF\n \"Pixel formats\".)\n\n @param jpegBuf address of a pointer to a byte buffer that will receive the\n JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n accommodate the size of the JPEG image.  Thus, you can choose to:\n -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n let TurboJPEG grow the buffer as needed,\n -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n or\n -# pre-allocate the buffer to a \"worst case\" size determined by calling\n #tj3JPEGBufSize() and adding the return value to the size of the ICC profile\n (if any) that was previously associated with the TurboJPEG instance (see\n #tj3SetICCProfile().)  This should ensure that the buffer never has to be\n re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n .\n Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`\n upon return from this function, as it may have changed.\n\n @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n should be set to the size of the buffer.  Otherwise, `*jpegSize` is\n ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a\n previous call to one of the JPEG compression functions, then `*jpegSize` is\n also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG\n image (in bytes.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3Compress16(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_ushort,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into\n an 8-bit-per-sample lossy @ref TJCS_YCbCr \"YCbCr\" or\n @ref TJCS_GRAY \"grayscale\" JPEG image.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n (or just a Y plane, if compressing a grayscale image) that contain a YUV\n source image to be compressed.  These planes can be contiguous or\n non-contiguous in memory.  The size of each plane should match the value\n returned by #tj3YUVPlaneSize() for the given image width, height, strides,\n and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer to\n @ref YUVnotes \"YUV Image Format Notes\" for more details.\n\n @param width width (in pixels) of the source image.  If the width is not an\n even multiple of the iMCU width (see #tjMCUWidth), then an intermediate\n buffer copy will be performed.\n\n @param strides an array of integers, each specifying the number of bytes per\n row in the corresponding plane of the YUV source image.  Setting the stride\n for any plane to 0 is the same as setting it to the plane width (see\n @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n strides for all planes will be set to their respective plane widths.  You\n can adjust the strides in order to specify an arbitrary amount of row\n padding in each plane or to create a JPEG image from a subregion of a larger\n planar YUV image.\n\n @param height height (in pixels) of the source image.  If the height is not\n an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate\n buffer copy will be performed.\n\n @param jpegBuf address of a pointer to a byte buffer that will receive the\n JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n accommodate the size of the JPEG image.  Thus, you can choose to:\n -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n let TurboJPEG grow the buffer as needed,\n -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n or\n -# pre-allocate the buffer to a \"worst case\" size determined by calling\n #tj3JPEGBufSize() and adding the return value to the size of the ICC profile\n (if any) that was previously associated with the TurboJPEG instance (see\n #tj3SetICCProfile().)  This should ensure that the buffer never has to be\n re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n .\n Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`\n upon return from this function, as it may have changed.\n\n @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n should be set to the size of the buffer.  Otherwise, `*jpegSize` is\n ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a\n previous call to one of the JPEG compression functions, then `*jpegSize` is\n also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG\n image (in bytes.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3CompressFromYUVPlanes8(
        handle: tjhandle,
        srcPlanes: *const *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        strides: *const ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compress an 8-bit-per-sample unified planar YUV image into an\n 8-bit-per-sample lossy @ref TJCS_YCbCr \"YCbCr\" or @ref TJCS_GRAY \"grayscale\"\n JPEG image.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcBuf pointer to a buffer containing a unified planar YUV source\n image to be compressed.  The size of this buffer should match the value\n returned by #tj3YUVBufSize() for the given image width, height, row\n alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n Y, U (Cb), and V (Cr) image planes should be stored sequentially in the\n buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n\n @param width width (in pixels) of the source image.  If the width is not an\n even multiple of the iMCU width (see #tjMCUWidth), then an intermediate\n buffer copy will be performed.\n\n @param align row alignment (in bytes) of the source image (must be a power\n of 2.)  Setting this parameter to n indicates that each row in each plane of\n the source image is padded to the nearest multiple of n bytes\n (1 = unpadded.)\n\n @param height height (in pixels) of the source image.  If the height is not\n an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate\n buffer copy will be performed.\n\n @param jpegBuf address of a pointer to a byte buffer that will receive the\n JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n accommodate the size of the JPEG image.  Thus, you can choose to:\n -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n let TurboJPEG grow the buffer as needed,\n -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n or\n -# pre-allocate the buffer to a \"worst case\" size determined by calling\n #tj3JPEGBufSize() and adding the return value to the size of the ICC profile\n (if any) that was previously associated with the TurboJPEG instance (see\n #tj3SetICCProfile().)  This should ensure that the buffer never has to be\n re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n .\n Unless you have set #TJPARAM_NOREALLOC, you should always check `*jpegBuf`\n upon return from this function, as it may have changed.\n\n @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n should be set to the size of the buffer.  Otherwise, `*jpegSize` is\n ignored.  If `*jpegBuf` points to a JPEG buffer that is being reused from a\n previous call to one of the JPEG compression functions, then `*jpegSize` is\n also ignored.  Upon return, `*jpegSize` will contain the size of the JPEG\n image (in bytes.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3CompressFromYUV8(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into separate\n 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs\n color conversion and downsampling (which are accelerated in the\n libjpeg-turbo implementation) but does not execute any of the other steps in\n the JPEG compression process.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale\n source image to be encoded.  This buffer should normally be `pitch * height`\n bytes in size.  However, you can also use this parameter to encode from a\n specific region of a larger buffer.\n\n\n @param width width (in pixels) of the source image\n\n @param pitch bytes per row in the source image.  Normally this should be\n <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n (Setting this parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n parameter to specify the row alignment/padding of the source image, to skip\n rows, or to encode from a specific region of a larger packed-pixel image.\n\n @param height height (in pixels) of the source image\n\n @param pixelFormat pixel format of the source image (see @ref TJPF\n \"Pixel formats\".)\n\n @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n (or just a Y plane, if generating a grayscale image) that will receive the\n encoded image.  These planes can be contiguous or non-contiguous in memory.\n Use #tj3YUVPlaneSize() to determine the appropriate size for each plane\n based on the image width, height, strides, and level of chrominance\n subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes\n \"YUV Image Format Notes\" for more details.\n\n @param strides an array of integers, each specifying the number of bytes per\n row in the corresponding plane of the YUV image.  Setting the stride for any\n plane to 0 is the same as setting it to the plane width (see @ref YUVnotes\n \"YUV Image Format Notes\".)  If `strides` is NULL, then the strides for all\n planes will be set to their respective plane widths.  You can adjust the\n strides in order to add an arbitrary amount of row padding to each plane or\n to encode an RGB or grayscale image into a subregion of a larger planar YUV\n image.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3EncodeYUVPlanes8(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstPlanes: *mut *mut ::std::os::raw::c_uchar,
        strides: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into an\n 8-bit-per-sample unified planar YUV image.  This function performs color\n conversion and downsampling (which are accelerated in the libjpeg-turbo\n implementation) but does not execute any of the other steps in the JPEG\n compression process.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n compression\n\n @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale\n source image to be encoded.  This buffer should normally be `pitch * height`\n bytes in size.  However, you can also use this parameter to encode from a\n specific region of a larger buffer.\n\n @param width width (in pixels) of the source image\n\n @param pitch bytes per row in the source image.  Normally this should be\n <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n (Setting this parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n parameter to specify the row alignment/padding of the source image, to skip\n rows, or to encode from a specific region of a larger packed-pixel image.\n\n @param height height (in pixels) of the source image\n\n @param pixelFormat pixel format of the source image (see @ref TJPF\n \"Pixel formats\".)\n\n @param dstBuf pointer to a buffer that will receive the unified planar YUV\n image.  Use #tj3YUVBufSize() to determine the appropriate size for this\n buffer based on the image width, height, row alignment, and level of\n chrominance subsampling (see #TJPARAM_SUBSAMP.)  The Y, U (Cb), and V (Cr)\n image planes will be stored sequentially in the buffer.  (Refer to\n @ref YUVnotes \"YUV Image Format Notes\".)\n\n @param align row alignment (in bytes) of the YUV image (must be a power of\n 2.)  Setting this parameter to n will cause each row in each plane of the\n YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)\n To generate images suitable for X Video, `align` should be set to 4.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3EncodeYUV8(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about a JPEG image without decompressing it, or prime\n the decompressor with quantization and Huffman tables.  If a JPEG image is\n passed to this function, then the @ref TJPARAM \"parameters\" that describe\n the JPEG image will be set when the function returns.  If a JPEG image is\n passed to this function and #TJPARAM_SAVEMARKERS is set to `2` or `4`, then\n the ICC profile (if any) will be extracted from the JPEG image.\n (#tj3GetICCProfile() can then be used to retrieve the profile.)\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param jpegBuf pointer to a byte buffer containing a JPEG image or an\n \"abbreviated table specification\" (AKA \"tables-only\") datastream.  Passing a\n tables-only datastream to this function primes the decompressor with\n quantization and Huffman tables that can be used when decompressing\n subsequent \"abbreviated image\" datastreams.  This is useful, for instance,\n when decompressing video streams in which all frames share the same\n quantization and Huffman tables.\n\n @param jpegSize size of the JPEG image or tables-only datastream (in bytes)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3DecompressHeader(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the ICC (International Color Consortium) color management profile\n (if any) that was previously extracted from a JPEG image.\n\n @note To extract the ICC profile from a JPEG image, call\n #tj3DecompressHeader() with #TJPARAM_SAVEMARKERS set to `2` or `4`.  Once\n the ICC profile is retrieved, it must be re-extracted before it can be\n retrieved again.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param iccBuf address of a pointer to a byte buffer.  Upon return:\n - If `iccBuf` is not NULL and there is an ICC profile to retrieve, then\n `*iccBuf` will point to a byte buffer containing the ICC profile.  This\n buffer should be freed using #tj3Free().\n - If `iccBuf` is not NULL and there is no ICC profile to retrieve, then\n `*iccBuf` will be NULL.\n - If `iccBuf` is NULL, then only the ICC profile size will be retrieved, and\n the ICC profile can be retrieved later.\n\n @param iccSize address of a size_t variable.  Upon return, the variable will\n contain the ICC profile size (or 0 if there is no ICC profile to retrieve.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3GetICCProfile(
        handle: tjhandle,
        iccBuf: *mut *mut ::std::os::raw::c_uchar,
        iccSize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns a list of fractional scaling factors that the JPEG decompressor\n supports.\n\n @param numScalingFactors pointer to an integer variable that will receive\n the number of elements in the list\n\n @return a pointer to a list of fractional scaling factors, or NULL if an\n error is encountered (see #tj3GetErrorStr().)"]
    pub fn tj3GetScalingFactors(
        numScalingFactors: *mut ::std::os::raw::c_int,
    ) -> *mut tjscalingfactor;
}
unsafe extern "C" {
    #[doc = " Set the scaling factor for subsequent lossy decompression operations.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param scalingFactor #tjscalingfactor structure that specifies a fractional\n scaling factor that the decompressor supports (see #tj3GetScalingFactors()),\n or <tt>#TJUNSCALED</tt> for no scaling.  Decompression scaling is a function\n of the IDCT algorithm, so scaling factors are generally limited to multiples\n of 1/8.  If the entire JPEG image will be decompressed, then the width and\n height of the scaled destination image can be determined by calling\n #TJSCALED() with the JPEG width and height (see #TJPARAM_JPEGWIDTH and\n #TJPARAM_JPEGHEIGHT) and the specified scaling factor.  When decompressing\n into a planar YUV image, an intermediate buffer copy will be performed if\n the width or height of the scaled destination image is not an even multiple\n of the iMCU size (see #tjMCUWidth and #tjMCUHeight.)  Note that\n decompression scaling is not available (and the specified scaling factor is\n ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),\n since the IDCT algorithm is not used with those images.  Note also that\n #TJPARAM_FASTDCT is ignored when decompression scaling is enabled.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetScalingFactor(
        handle: tjhandle,
        scalingFactor: tjscalingfactor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the cropping region for partially decompressing a lossy JPEG image into\n a packed-pixel image\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param croppingRegion #tjregion structure that specifies a subregion of the\n JPEG image to decompress, or <tt>#TJUNCROPPED</tt> for no cropping.  The\n left boundary of the cropping region must be evenly divisible by the scaled\n iMCU width-- <tt>#TJSCALED(#tjMCUWidth[subsamp], scalingFactor)</tt>, where\n `subsamp` is the level of chrominance subsampling in the JPEG image (see\n #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression scaling factor\n (see #tj3SetScalingFactor().)  The cropping region should be specified\n relative to the scaled image dimensions.  Unless `croppingRegion` is\n <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see\n #tj3DecompressHeader()) prior to calling this function.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetCroppingRegion(
        handle: tjhandle,
        croppingRegion: tjregion,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decompress a JPEG image with 2 to 8 bits of data precision per sample into a\n packed-pixel RGB, grayscale, or CMYK image with the same data precision.\n The @ref TJPARAM \"parameters\" that describe the JPEG image will be set when\n this function returns.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param jpegBuf pointer to a byte buffer containing the JPEG image to\n decompress\n\n @param jpegSize size of the JPEG image (in bytes)\n\n @param dstBuf pointer to a buffer that will receive the packed-pixel\n decompressed image.  This buffer should normally be\n `pitch * destinationHeight` samples in size.  However, you can also use this\n parameter to decompress into a specific region of a larger buffer.  NOTE:\n If the JPEG image is lossy, then `destinationHeight` is either the scaled\n JPEG height (see #TJSCALED(), #TJPARAM_JPEGHEIGHT, and\n #tj3SetScalingFactor()) or the height of the cropping region (see\n #tj3SetCroppingRegion().)  If the JPEG image is lossless, then\n `destinationHeight` is the JPEG height.\n\n @param pitch samples per row in the destination image.  Normally this should\n be set to <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>, if the\n destination image should be unpadded.  (Setting this parameter to 0 is the\n equivalent of setting it to\n <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n also use this parameter to specify the row alignment/padding of the\n destination image, to skip rows, or to decompress into a specific region of\n a larger buffer.  NOTE: If the JPEG image is lossy, then `destinationWidth`\n is either the scaled JPEG width (see #TJSCALED(), #TJPARAM_JPEGWIDTH, and\n #tj3SetScalingFactor()) or the width of the cropping region (see\n #tj3SetCroppingRegion().)  If the JPEG image is lossless, then\n `destinationWidth` is the JPEG width.\n\n @param pixelFormat pixel format of the destination image (see @ref\n TJPF \"Pixel formats\".)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3Decompress8(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
        dstBuf: *mut ::std::os::raw::c_uchar,
        pitch: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decompress a JPEG image with 9 to 12 bits of data precision per sample into\n a packed-pixel RGB, grayscale, or CMYK image with the same data precision.\n\n \\details \\copydetails tj3Decompress8()"]
    pub fn tj3Decompress12(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
        dstBuf: *mut ::std::os::raw::c_short,
        pitch: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decompress a lossless JPEG image with 13 to 16 bits of data precision per\n sample into a packed-pixel RGB, grayscale, or CMYK image with the same\n data precision.\n\n \\details \\copydetails tj3Decompress8()"]
    pub fn tj3Decompress16(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
        dstBuf: *mut ::std::os::raw::c_ushort,
        pitch: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decompress an 8-bit-per-sample lossy JPEG image into separate\n 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs\n JPEG decompression but leaves out the color conversion step, so a planar YUV\n image is generated instead of a packed-pixel image.  The\n @ref TJPARAM \"parameters\" that describe the JPEG image will be set when this\n function returns.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param jpegBuf pointer to a byte buffer containing the JPEG image to\n decompress\n\n @param jpegSize size of the JPEG image (in bytes)\n\n @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n (or just a Y plane, if decompressing a grayscale image) that will receive\n the decompressed image.  These planes can be contiguous or non-contiguous in\n memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for each\n plane based on the scaled JPEG width and height (see #TJSCALED(),\n #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),\n strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer\n to @ref YUVnotes \"YUV Image Format Notes\" for more details.\n\n @param strides an array of integers, each specifying the number of bytes per\n row in the corresponding plane of the YUV image.  Setting the stride for any\n plane to 0 is the same as setting it to the scaled plane width (see\n @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n strides for all planes will be set to their respective scaled plane widths.\n You can adjust the strides in order to add an arbitrary amount of row\n padding to each plane or to decompress the JPEG image into a subregion of a\n larger planar YUV image.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3DecompressToYUVPlanes8(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
        dstPlanes: *mut *mut ::std::os::raw::c_uchar,
        strides: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decompress an 8-bit-per-sample lossy JPEG image into an 8-bit-per-sample\n unified planar YUV image.  This function performs JPEG decompression but\n leaves out the color conversion step, so a planar YUV image is generated\n instead of a packed-pixel image.  The @ref TJPARAM \"parameters\" that\n describe the JPEG image will be set when this function returns.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param jpegBuf pointer to a byte buffer containing the JPEG image to\n decompress\n\n @param jpegSize size of the JPEG image (in bytes)\n\n @param dstBuf pointer to a buffer that will receive the unified planar YUV\n decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size\n for this buffer based on the scaled JPEG width and height (see #TJSCALED(),\n #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row\n alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n Y, U (Cb), and V (Cr) image planes will be stored sequentially in the\n buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n\n @param align row alignment (in bytes) of the YUV image (must be a power of\n 2.)  Setting this parameter to n will cause each row in each plane of the\n YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)\n To generate images suitable for X Video, `align` should be set to 4.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3DecompressToYUV8(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
        dstBuf: *mut ::std::os::raw::c_uchar,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into an\n 8-bit-per-sample packed-pixel RGB or grayscale image.  This function\n performs color conversion (which is accelerated in the libjpeg-turbo\n implementation) but does not execute any of the other steps in the JPEG\n decompression process.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n (or just a Y plane, if decoding a grayscale image) that contain a YUV image\n to be decoded.  These planes can be contiguous or non-contiguous in memory.\n The size of each plane should match the value returned by #tj3YUVPlaneSize()\n for the given image width, height, strides, and level of chrominance\n subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes\n \"YUV Image Format Notes\" for more details.\n\n @param strides an array of integers, each specifying the number of bytes per\n row in the corresponding plane of the YUV source image.  Setting the stride\n for any plane to 0 is the same as setting it to the plane width (see\n @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n strides for all planes will be set to their respective plane widths.  You\n can adjust the strides in order to specify an arbitrary amount of row\n padding in each plane or to decode a subregion of a larger planar YUV image.\n\n @param dstBuf pointer to a buffer that will receive the packed-pixel decoded\n image.  This buffer should normally be `pitch * height` bytes in size.\n However, you can also use this parameter to decode into a specific region of\n a larger buffer.\n\n @param width width (in pixels) of the source and destination images\n\n @param pitch bytes per row in the destination image.  Normally this should\n be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination\n image should be unpadded.  (Setting this parameter to 0 is the equivalent of\n setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n also use this parameter to specify the row alignment/padding of the\n destination image, to skip rows, or to decode into a specific region of a\n larger buffer.\n\n @param height height (in pixels) of the source and destination images\n\n @param pixelFormat pixel format of the destination image (see @ref TJPF\n \"Pixel formats\".)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3DecodeYUVPlanes8(
        handle: tjhandle,
        srcPlanes: *const *const ::std::os::raw::c_uchar,
        strides: *const ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode an 8-bit-per-sample unified planar YUV image into an 8-bit-per-sample\n packed-pixel RGB or grayscale image.  This function performs color\n conversion (which is accelerated in the libjpeg-turbo implementation) but\n does not execute any of the other steps in the JPEG decompression process.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n decompression\n\n @param srcBuf pointer to a buffer containing a unified planar YUV source\n image to be decoded.  The size of this buffer should match the value\n returned by #tj3YUVBufSize() for the given image width, height, row\n alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n Y, U (Cb), and V (Cr) image planes should be stored sequentially in the\n source buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n\n @param align row alignment (in bytes) of the YUV source image (must be a\n power of 2.)  Setting this parameter to n indicates that each row in each\n plane of the YUV source image is padded to the nearest multiple of n bytes\n (1 = unpadded.)\n\n @param dstBuf pointer to a buffer that will receive the packed-pixel decoded\n image.  This buffer should normally be `pitch * height` bytes in size.\n However, you can also use this parameter to decode into a specific region of\n a larger buffer.\n\n @param width width (in pixels) of the source and destination images\n\n @param pitch bytes per row in the destination image.  Normally this should\n be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination\n image should be unpadded.  (Setting this parameter to 0 is the equivalent of\n setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n also use this parameter to specify the row alignment/padding of the\n destination image, to skip rows, or to decode into a specific region of a\n larger buffer.\n\n @param height height (in pixels) of the source and destination images\n\n @param pixelFormat pixel format of the destination image (see @ref TJPF\n \"Pixel formats\".)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3DecodeYUV8(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        align: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image\n transformed with the given transform parameters and/or cropping region.\n This function is a wrapper for #tj3JPEGBufSize() that takes into account\n cropping, transposition of the width and height (which affects the\n destination image dimensions and level of chrominance subsampling),\n grayscale conversion, and the ICC profile (if any) that was previously\n associated with the TurboJPEG instance (see #tj3SetICCProfile()) or\n extracted from the source image (see #tj3GetICCProfile() and\n #TJPARAM_SAVEMARKERS.)  The JPEG header must be read (see\n tj3DecompressHeader()) prior to calling this function.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n lossless transformation\n\n @param transform pointer to a #tjtransform structure that specifies the\n transform parameters and/or cropping region for the JPEG image.\n\n @return the maximum size of the buffer (in bytes) required to hold the\n transformed image, or 0 if an error occurred (see #tj3GetErrorStr() and\n #tj3GetErrorCode().)"]
    pub fn tj3TransformBufSize(handle: tjhandle, transform: *const tjtransform) -> usize;
}
unsafe extern "C" {
    #[doc = " Losslessly transform a JPEG image into another JPEG image.  Lossless\n transforms work by moving the raw DCT coefficients from one JPEG image\n structure to another without altering the values of the coefficients.  While\n this is typically faster than decompressing the image, transforming it, and\n re-compressing it, lossless transforms are not free.  Each lossless\n transform requires reading and performing entropy decoding on all of the\n coefficients in the source image, regardless of the size of the destination\n image.  Thus, this function provides a means of generating multiple\n transformed images from the same source or applying multiple transformations\n simultaneously, in order to eliminate the need to read the source\n coefficients multiple times.\n\n @param handle handle to a TurboJPEG instance that has been initialized for\n lossless transformation\n\n @param jpegBuf pointer to a byte buffer containing the JPEG source image to\n transform\n\n @param jpegSize size of the JPEG source image (in bytes)\n\n @param n the number of transformed JPEG images to generate\n\n @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will\n receive a JPEG image that has been transformed using the parameters in\n `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG\n destination buffer to accommodate the size of the transformed JPEG image.\n Thus, you can choose to:\n -# pre-allocate the JPEG destination buffer with an arbitrary size using\n #tj3Alloc() and let TurboJPEG grow the buffer as needed,\n -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for\n you, or\n -# pre-allocate the buffer to a \"worst case\" size determined by calling\n #tj3TransformBufSize().  Under normal circumstances, this should ensure that\n the buffer never has to be re-allocated.  (Setting #TJPARAM_NOREALLOC\n guarantees that it won't be.  However, if the source image has a large\n amount of embedded Exif data, then the transformed JPEG image may be larger\n than the worst-case size.  #TJPARAM_NOREALLOC cannot be used in that case\n unless the embedded data is discarded using #TJXOPT_COPYNONE or\n #TJPARAM_SAVEMARKERS.)\n .\n Unless you have set #TJPARAM_NOREALLOC, you should always check `dstBufs[i]`\n upon return from this function, as it may have changed.\n\n @param dstSizes pointer to an array of n size_t variables that will receive\n the actual sizes (in bytes) of each transformed JPEG image.  If `dstBufs[i]`\n points to a pre-allocated buffer, then `dstSizes[i]` should be set to the\n size of the buffer.  Otherwise, `dstSizes[i]` is ignored.  Upon return,\n `dstSizes[i]` will contain the size of the transformed JPEG image (in\n bytes.)\n\n @param transforms pointer to an array of n #tjtransform structures, each of\n which specifies the transform parameters and/or cropping region for the\n corresponding transformed JPEG image.\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n and #tj3GetErrorCode().)"]
    pub fn tj3Transform(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: usize,
        n: ::std::os::raw::c_int,
        dstBufs: *mut *mut ::std::os::raw::c_uchar,
        dstSizes: *mut usize,
        transforms: *const tjtransform,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Load a packed-pixel image with 2 to 8 bits of data precision per sample from\n disk into memory.\n\n @param handle handle to a TurboJPEG instance\n\n @param filename name of a file containing a packed-pixel image in Windows\n BMP or PBMPLUS (PPM/PGM) format.  Windows BMP files require 8-bit-per-sample\n data precision.  When loading a PBMPLUS file, the target data precision\n (from 2 to 8 bits per sample) can be specified using #TJPARAM_PRECISION and\n defaults to 8 if #TJPARAM_PRECISION is unset or out of range.  If the data\n precision of the PBMPLUS file does not match the target data precision, then\n upconverting or downconverting will be performed.\n\n @param width pointer to an integer variable that will receive the width (in\n pixels) of the packed-pixel image\n\n @param align row alignment (in samples) of the packed-pixel buffer to be\n returned (must be a power of 2.)  Setting this parameter to n will cause all\n rows in the buffer to be padded to the nearest multiple of n samples\n (1 = unpadded.)\n\n @param height pointer to an integer variable that will receive the height\n (in pixels) of the packed-pixel image\n\n @param pixelFormat pointer to an integer variable that specifies or will\n receive the pixel format of the packed-pixel buffer.  The behavior of this\n function varies depending on the value of `*pixelFormat` passed to the\n function:\n - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will\n use the most optimal pixel format for the file type, and `*pixelFormat` will\n contain the ID of that pixel format upon successful return from this\n function.\n - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a\n grayscale colormap can be loaded.\n - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be\n converted using a quick & dirty algorithm that is suitable only for testing\n purposes.  (Proper conversion between CMYK and other formats requires a\n color management system.)\n - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the\n specified pixel format, and pixel format conversion will be performed if\n necessary.\n\n @return a pointer to a newly-allocated buffer containing the packed-pixel\n image, converted to the chosen pixel format and with the chosen row\n alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This\n buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage8(
        handle: tjhandle,
        filename: *const ::std::os::raw::c_char,
        width: *mut ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        pixelFormat: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = " Load a packed-pixel image with 9 to 12 bits of data precision per sample\n from disk into memory.\n\n @param handle handle to a TurboJPEG instance\n\n @param filename name of a file containing a packed-pixel image in PBMPLUS\n (PPM/PGM) format.  The target data precision (from 9 to 12 bits per sample)\n can be specified using #TJPARAM_PRECISION and defaults to 12 if\n #TJPARAM_PRECISION is unset or out of range.  If the data precision of the\n PBMPLUS file does not match the target data precision, then upconverting or\n downconverting will be performed.\n\n @param width pointer to an integer variable that will receive the width (in\n pixels) of the packed-pixel image\n\n @param align row alignment (in samples) of the packed-pixel buffer to be\n returned (must be a power of 2.)  Setting this parameter to n will cause all\n rows in the buffer to be padded to the nearest multiple of n samples\n (1 = unpadded.)\n\n @param height pointer to an integer variable that will receive the height\n (in pixels) of the packed-pixel image\n\n @param pixelFormat pointer to an integer variable that specifies or will\n receive the pixel format of the packed-pixel buffer.  The behavior of this\n function will vary depending on the value of `*pixelFormat` passed to the\n function:\n - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will\n use the most optimal pixel format for the file type, and `*pixelFormat` will\n contain the ID of that pixel format upon successful return from this\n function.\n - @ref TJPF_GRAY : Only PGM files can be loaded.\n - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be\n converted using a quick & dirty algorithm that is suitable only for testing\n purposes.  (Proper conversion between CMYK and other formats requires a\n color management system.)\n - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the\n specified pixel format, and pixel format conversion will be performed if\n necessary.\n\n @return a pointer to a newly-allocated buffer containing the packed-pixel\n image, converted to the chosen pixel format and with the chosen row\n alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This\n buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage12(
        handle: tjhandle,
        filename: *const ::std::os::raw::c_char,
        width: *mut ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        pixelFormat: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_short;
}
unsafe extern "C" {
    #[doc = " Load a packed-pixel image with 13 to 16 bits of data precision per sample\n from disk into memory.\n\n @param handle handle to a TurboJPEG instance\n\n @param filename name of a file containing a packed-pixel image in PBMPLUS\n (PPM/PGM) format.  The target data precision (from 13 to 16 bits per sample)\n can be specified using #TJPARAM_PRECISION and defaults to 16 if\n #TJPARAM_PRECISION is unset or out of range.  If the data precision of the\n PBMPLUS file does not match the target data precision, then upconverting or\n downconverting will be performed.\n\n @param width pointer to an integer variable that will receive the width (in\n pixels) of the packed-pixel image\n\n @param align row alignment (in samples) of the packed-pixel buffer to be\n returned (must be a power of 2.)  Setting this parameter to n will cause all\n rows in the buffer to be padded to the nearest multiple of n samples\n (1 = unpadded.)\n\n @param height pointer to an integer variable that will receive the height\n (in pixels) of the packed-pixel image\n\n @param pixelFormat pointer to an integer variable that specifies or will\n receive the pixel format of the packed-pixel buffer.  The behavior of this\n function will vary depending on the value of `*pixelFormat` passed to the\n function:\n - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will\n use the most optimal pixel format for the file type, and `*pixelFormat` will\n contain the ID of that pixel format upon successful return from this\n function.\n - @ref TJPF_GRAY : Only PGM files can be loaded.\n - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be\n converted using a quick & dirty algorithm that is suitable only for testing\n purposes.  (Proper conversion between CMYK and other formats requires a\n color management system.)\n - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the\n specified pixel format, and pixel format conversion will be performed if\n necessary.\n\n @return a pointer to a newly-allocated buffer containing the packed-pixel\n image, converted to the chosen pixel format and with the chosen row\n alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This\n buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage16(
        handle: tjhandle,
        filename: *const ::std::os::raw::c_char,
        width: *mut ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        pixelFormat: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    #[doc = " Save a packed-pixel image with 2 to 8 bits of data precision per sample from\n memory to disk.\n\n @param handle handle to a TurboJPEG instance\n\n @param filename name of a file to which to save the packed-pixel image.  The\n image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending\n on the file extension.  Windows BMP files require 8-bit-per-sample data\n precision.  When saving a PBMPLUS file, the source data precision (from 2 to\n 8 bits per sample) can be specified using #TJPARAM_PRECISION and defaults to\n 8 if #TJPARAM_PRECISION is unset or out of range.\n\n @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,\n or CMYK image to be saved\n\n @param width width (in pixels) of the packed-pixel image\n\n @param pitch samples per row in the packed-pixel image.  Setting this\n parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.\n\n @param height height (in pixels) of the packed-pixel image\n\n @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF\n \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the\n image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format.\n Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format.\n If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be\n converted to RGB using a quick & dirty algorithm that is suitable only for\n testing purposes.  (Proper conversion between CMYK and other formats\n requires a color management system.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage8(
        handle: tjhandle,
        filename: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Save a packed-pixel image with 9 to 12 bits of data precision per sample\n from memory to disk.\n\n @param handle handle to a TurboJPEG instance\n\n @param filename name of a file to which to save the packed-pixel image,\n which will be stored in PBMPLUS (PPM/PGM) format.  The source data precision\n (from 9 to 12 bits per sample) can be specified using #TJPARAM_PRECISION and\n defaults to 12 if #TJPARAM_PRECISION is unset or out of range.\n\n @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,\n or CMYK image to be saved\n\n @param width width (in pixels) of the packed-pixel image\n\n @param pitch samples per row in the packed-pixel image.  Setting this\n parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.\n\n @param height height (in pixels) of the packed-pixel image\n\n @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF\n \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the\n image will be stored in PGM format.  Otherwise, the image will be stored in\n PPM format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK\n pixels will be converted to RGB using a quick & dirty algorithm that is\n suitable only for testing purposes.  (Proper conversion between CMYK and\n other formats requires a color management system.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage12(
        handle: tjhandle,
        filename: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_short,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Save a packed-pixel image with 13 to 16 bits of data precision per sample\n from memory to disk.\n\n @param handle handle to a TurboJPEG instance\n\n @param filename name of a file to which to save the packed-pixel image,\n which will be stored in PBMPLUS (PPM/PGM) format.  The source data precision\n (from 13 to 16 bits per sample) can be specified using #TJPARAM_PRECISION\n and defaults to 16 if #TJPARAM_PRECISION is unset or out of range.\n\n @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,\n or CMYK image to be saved\n\n @param width width (in pixels) of the packed-pixel image\n\n @param pitch samples per row in the packed-pixel image.  Setting this\n parameter to 0 is the equivalent of setting it to\n <tt>width * #tjPixelSize[pixelFormat]</tt>.\n\n @param height height (in pixels) of the packed-pixel image\n\n @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF\n \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the\n image will be stored in PGM format.  Otherwise, the image will be stored in\n PPM format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK\n pixels will be converted to RGB using a quick & dirty algorithm that is\n suitable only for testing purposes.  (Proper conversion between CMYK and\n other formats requires a color management system.)\n\n @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage16(
        handle: tjhandle,
        filename: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_ushort,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjCompress(
        handle: tjhandle,
        srcBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelSize: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        compressedSize: *mut ::std::os::raw::c_ulong,
        jpegSubsamp: ::std::os::raw::c_int,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompress(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelSize: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompressHeader(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDestroy(handle: tjhandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjGetErrorStr() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tjInitCompress() -> tjhandle;
}
unsafe extern "C" {
    pub fn tjInitDecompress() -> tjhandle;
}
unsafe extern "C" {
    pub fn tjDecompressHeader2(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        jpegSubsamp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompressToYUV(
        handle: tjhandle,
        jpegBuf: *mut ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjEncodeYUV(
        handle: tjhandle,
        srcBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelSize: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjAlloc(bytes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn tjBufSize(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        jpegSubsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn tjBufSizeYUV(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn tjCompress2(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut ::std::os::raw::c_ulong,
        jpegSubsamp: ::std::os::raw::c_int,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompress2(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjEncodeYUV2(
        handle: tjhandle,
        srcBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjFree(buffer: *mut ::std::os::raw::c_uchar);
}
unsafe extern "C" {
    pub fn tjGetScalingFactors(
        numscalingfactors: *mut ::std::os::raw::c_int,
    ) -> *mut tjscalingfactor;
}
unsafe extern "C" {
    pub fn tjInitTransform() -> tjhandle;
}
unsafe extern "C" {
    pub fn tjTransform(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_int,
        dstBufs: *mut *mut ::std::os::raw::c_uchar,
        dstSizes: *mut ::std::os::raw::c_ulong,
        transforms: *mut tjtransform,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjBufSizeYUV2(
        width: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn tjCompressFromYUV(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut ::std::os::raw::c_ulong,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjCompressFromYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        strides: *const ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        jpegBuf: *mut *mut ::std::os::raw::c_uchar,
        jpegSize: *mut ::std::os::raw::c_ulong,
        jpegQual: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecodeYUV(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        align: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecodeYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const ::std::os::raw::c_uchar,
        strides: *const ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompressHeader3(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        jpegSubsamp: *mut ::std::os::raw::c_int,
        jpegColorspace: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompressToYUV2(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstBuf: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjDecompressToYUVPlanes(
        handle: tjhandle,
        jpegBuf: *const ::std::os::raw::c_uchar,
        jpegSize: ::std::os::raw::c_ulong,
        dstPlanes: *mut *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        strides: *mut ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjEncodeYUV3(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstBuf: *mut ::std::os::raw::c_uchar,
        align: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjEncodeYUVPlanes(
        handle: tjhandle,
        srcBuf: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        dstPlanes: *mut *mut ::std::os::raw::c_uchar,
        strides: *mut ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjPlaneHeight(
        componentID: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjPlaneSizeYUV(
        componentID: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn tjPlaneWidth(
        componentID: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        subsamp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjGetErrorCode(handle: tjhandle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tjGetErrorStr2(handle: tjhandle) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tjLoadImage(
        filename: *const ::std::os::raw::c_char,
        width: *mut ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        pixelFormat: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn tjSaveImage(
        filename: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pixelFormat: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
